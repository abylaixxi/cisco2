<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тренажёр сопоставлений (7 вопросов)</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f4f4; padding: 20px; }
        #quiz-container { max-width: 800px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.2); }
        .question { font-size: 20px; margin-bottom: 25px; font-weight: bold; }
        #feedback { font-weight: bold; margin: 20px 0; min-height: 30px; font-size: 18px; }
        button {
            padding: 12px 25px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover { background: #0056b3; }
        #retry { background: #fd7e14; }
        #retry:hover { background: #e86200; }
        .correct { background-color: #d4edda; border: 2px solid #28a745; }
        .incorrect { background-color: #f8d7da; border: 2px solid #dc3545; }
        .matching-table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .matching-table td { padding: 12px; vertical-align: middle; border-bottom: 1px solid #ddd; }
        .matching-left { font-weight: bold; width: 45%; }
        .matching-right select { width: 100%; padding: 10px; font-size: 16px; border-radius: 5px; border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div id="quiz-container">
        <div id="question" class="question"></div>
        <div id="options" class="options"></div>
        <div id="feedback"></div>
        <button id="submit">Проверить</button>
        <button id="retry" style="display: none;">Попробовать ещё раз</button>
        <button id="next" style="display: none;">Следующий вопрос</button>
    </div>

    <script>
        const questions = [
            {
                type: 'matching',
                question: '10. Match the healthcare sector term to the respective description.',
                left: ['Healthcare provider', 'Business associates', 'Health plan', 'Healthcare clearinghouse'],
                right: [
                    'A person or an organization that provides patient or medical services',
                    'A person or organization that performs certain functions involving the use of PHI on behalf of, or provides services to, a covered entity',
                    'A government program that pays for healthcare',
                    'An entity that processes nonstandard health information it receives from another entity into a standard format'
                ],
                correct: {0: 0, 1: 1, 2: 2, 3: 3}
            },
            {
                type: 'matching',
                question: '14. Match penetration testing methodology and standard with the respective description.',
                left: ['OSSTMM', 'NIST', 'MITRE ATT&CK', 'OWASP WSTG'],
                right: [
                    'This is a peer-reviewed security testing methodology maintained by the Institute for Security and Open Methodologies (ISECOM).',
                    'This is a document created to provide organizations with guidelines on planning and conducting information security testing.',
                    'This is a resource for learning about the tactics of an adversary, techniques, and procedures (TTPs).',
                    'This is a compilation of high-level phases of web application security testing and digs deeper into the testing methods used.'
                ],
                correct: {0: 0, 1: 1, 2: 2, 3: 3}
            },
            {
                type: 'matching',
                question: '30. Match the cloud attack to the description.',
                left: ['Credential Harvesting', 'Account Takeover', 'Privilege Escalation'],
                right: [
                    'Act of gathering and stealing valid usernames, passwords, tokens, PINs, and any other types of credentials through infrastructure breaches',
                    'When a threat actor gains access to a user or application account and uses it to then gain access to more accounts and information',
                    'Act of exploiting a bug or design flaw in a software or firmware application to gain access to resources that normally would have been protected from an application or a user'
                ],
                correct: {0: 0, 1: 1, 2: 2}
            },
            {
                type: 'matching',
                question: '32. Match the mobile device security testing tool to the description.',
                left: ['Drozer', 'Needle', 'ApkX', 'Burp Suite'],
                right: [
                    'This Android testing platform and framework provides access to numerous exploits that can be used to attack Android platforms.',
                    'This open-source framework is used to test the security of iOS applications.',
                    'This tool enables you to decompile Android application package files.',
                    'This can test mobile applications and determine how they communicate with web services and APIs.'
                ],
                correct: {0: 0, 1: 1, 2: 2, 3: 3}
            },
            {
                type: 'matching',
                question: '33. Match the mobile device attack to the description.',
                left: ['Spamming', 'Reverse engineering', 'Sandbox analysis'],
                right: [
                    'This presents users with links to redirect them to malicious sites to steal sensitive information or install malware.',
                    'This is the process of analyzing a mobile app to extract information about the source code to understand the underlying architecture of a mobile application and potentially manipulate the mobile device.',
                    'This can enable a threat actor to bypass the access control mechanisms implemented by Android, Apple iOS, and mobile app developers.'
                ],
                correct: {0: 0, 1: 1, 2: 2}
            },
            {
                type: 'matching',
                question: '35. Match the insecure code practice to the description.',
                left: ['Lack of error handling and overly verbose error handling', 'Comments in source code', 'Unprotected APIs', 'Hard-coded credentials'],
                right: [
                    'A type of weakness and security malpractice that can provide information to help an attacker perform additional attacks on the targeted system.',
                    'Developers include information in source code that could provide too much information and might be leveraged by an attacker.',
                    'Many APIs lack adequate controls and are difficult to monitor. The breadth and complexity of APIs also make it difficult to automate effective security testing.',
                    'A catastrophic flaw that an attacker can leverage to completely compromise an application or the underlying system.'
                ],
                correct: {0: 0, 1: 1, 2: 2, 3: 3}
            },
            {
                type: 'matching',
                question: '38. Match the PowerSploit module/script to the respective description.',
                left: ['Invoke-Portscan', 'Set-CriticalProcess', 'PowerView', 'Get-VaultCredential', 'PowerUp'],
                right: [
                    'Does a simple TCP port scan using regular sockets, based rather loosely on Nmap',
                    'Causes the machine to blue screen upon exiting PowerShell',
                    'Performs network and Windows domain enumeration and exploitation',
                    'Displays Windows vault credential objects, including plaintext web credentials',
                    'Acts as clearinghouse of common privilege escalation checks, along with some weaponization vectors'
                ],
                correct: {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}
            }
        ];

        let currentQuestionIndex = Math.floor(Math.random() * questions.length);
        let currentQuestion = questions[currentQuestionIndex];

        function loadQuestion() {
            const questionElem = document.getElementById('question');
            const optionsElem = document.getElementById('options');
            const feedbackElem = document.getElementById('feedback');
            const submitBtn = document.getElementById('submit');
            const retryBtn = document.getElementById('retry');
            const nextBtn = document.getElementById('next');
            const container = document.getElementById('quiz-container');

            container.classList.remove('correct', 'incorrect');
            feedbackElem.innerHTML = '';
            optionsElem.innerHTML = '';
            submitBtn.style.display = 'inline';
            retryBtn.style.display = 'none';
            nextBtn.style.display = 'none';

            questionElem.textContent = currentQuestion.question;

            const table = document.createElement('table');
            table.classList.add('matching-table');

            currentQuestion.left.forEach((leftItem, index) => {
                const row = document.createElement('tr');

                const leftTd = document.createElement('td');
                leftTd.classList.add('matching-left');
                leftTd.textContent = leftItem;
                row.appendChild(leftTd);

                const arrowTd = document.createElement('td');
                arrowTd.textContent = '→';
                arrowTd.style.textAlign = 'center';
                arrowTd.style.fontWeight = 'bold';
                row.appendChild(arrowTd);

                const rightTd = document.createElement('td');
                rightTd.classList.add('matching-right');
                const select = document.createElement('select');
                select.dataset.leftIndex = index;

                const defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = '-- выберите --';
                select.appendChild(defaultOpt);

                // Перемешиваем правые варианты
                const shuffledRight = [...currentQuestion.right];
                for (let i = shuffledRight.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledRight[i], shuffledRight[j]] = [shuffledRight[j], shuffledRight[i]];
                }

                shuffledRight.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = currentQuestion.right.indexOf(item);
                    opt.textContent = item;
                    select.appendChild(opt);
                });

                rightTd.appendChild(select);
                row.appendChild(rightTd);

                table.appendChild(row);
            });

            optionsElem.appendChild(table);
        }

        function checkAnswer() {
            const feedbackElem = document.getElementById('feedback');
            const container = document.getElementById('quiz-container');
            const submitBtn = document.getElementById('submit');
            const retryBtn = document.getElementById('retry');
            const nextBtn = document.getElementById('next');

            const selects = document.querySelectorAll('select');
            const userMatches = {};
            let allSelected = true;

            selects.forEach(select => {
                const leftIndex = parseInt(select.dataset.leftIndex);
                const selectedValue = parseInt(select.value);
                if (select.value === '') allSelected = false;
                userMatches[leftIndex] = selectedValue;
            });

            if (!allSelected) {
                feedbackElem.innerHTML = '<strong>Пожалуйста, выберите соответствие для всех строк!</strong>';
                return;
            }

            let isCorrect = Object.keys(currentQuestion.correct).every(key => 
                currentQuestion.correct[key] === userMatches[key]
            );

            submitBtn.style.display = 'none';

            if (isCorrect) {
                container.classList.add('correct');
                feedbackElem.innerHTML = '<strong>Правильно!</strong>';
                nextBtn.style.display = 'inline';
            } else {
                container.classList.add('incorrect');
                feedbackElem.innerHTML = '<strong>Неправильно.</strong> Правильные соответствия:<br>' + getCorrectAnswerText();
                retryBtn.style.display = 'inline';
            }
        }

        function getCorrectAnswerText() {
            return Object.entries(currentQuestion.correct)
                .map(([left, right]) => `${currentQuestion.left[left]} → ${currentQuestion.right[right]}`)
                .join('<br>');
        }

        function retryQuestion() {
            loadQuestion();
        }

        function nextQuestion() {
            currentQuestionIndex = Math.floor(Math.random() * questions.length);
            currentQuestion = questions[currentQuestionIndex];
            loadQuestion();
        }

        document.getElementById('submit').addEventListener('click', checkAnswer);
        document.getElementById('retry').addEventListener('click', retryQuestion);
        document.getElementById('next').addEventListener('click', nextQuestion);

        loadQuestion();
    </script>
</body>
</html>
