<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Подготовка к сессии — 7 вопросов сопоставления</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            padding: 20px;
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #start-screen, #quiz-container, #result-screen {
            max-width: 800px;
            width: 100%;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            text-align: center;
        }
        #start-screen h1 { font-size: 32px; margin-bottom: 30px; }
        #start-btn {
            padding: 20px 50px;
            font-size: 28px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        #start-btn:hover { background: #218838; }

        #quiz-container { display: none; }
        .question-number { font-size: 20px; color: #555; margin-bottom: 15px; }
        .question { font-size: 22px; margin-bottom: 25px; font-weight: bold; }
        .options { margin-bottom: 30px; }
        #feedback { font-weight: bold; margin: 20px 0; min-height: 40px; font-size: 20px; }
        button {
            padding: 14px 30px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            margin: 10px;
        }
        button:hover { background: #0056b3; }
        #retry { background: #fd7e14; }
        #retry:hover { background: #e86200; }
        .correct { background-color: #d4edda !important; border: 3px solid #28a745; }
        .incorrect { background-color: #f8d7da !important; border: 3px solid #dc3545; }

        .matching-table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .matching-table td { padding: 15px; vertical-align: middle; border-bottom: 1px solid #ddd; }
        .matching-left { font-weight: bold; font-size: 18px; width: 45%; }
        .matching-right select { width: 100%; padding: 12px; font-size: 18px; border-radius: 5px; border: 1px solid #ccc; }

        #result-screen { display: none; }
        #result-screen h2 { font-size: 36px; margin-bottom: 20px; }
        #result-score { font-size: 52px; font-weight: bold; color: #28a745; margin: 30px 0; }
        #result-text { font-size: 22px; margin: 20px 0; }
        #restart-btn {
            padding: 18px 50px;
            font-size: 24px;
            background: #28a745;
        }
        #restart-btn:hover { background: #218838; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>Тренажёр сопоставлений</h1>
        <p>7 вопросов по кибербезопасности</p>
        <p>Полностью случайный порядок: вопросов, левых элементов и вариантов</p>
        <button id="start-btn">СТАРТ</button>
    </div>

    <div id="quiz-container">
        <div class="question-number" id="question-counter"></div>
        <div id="question" class="question"></div>
        <div id="options" class="options"></div>
        <div id="feedback"></div>
        <button id="submit">Проверить</button>
        <button id="retry" style="display: none;">Попробовать ещё раз</button>
        <button id="next" style="display: none;">Следующий вопрос</button>
    </div>

    <div id="result-screen">
        <h2>Тест завершён!</h2>
        <div id="result-score"></div>
        <p id="result-text"></p>
        <button id="restart-btn">Пройти заново</button>
    </div>

    <script>
        const originalQuestions = [
            {
                type: 'matching',
                question: '10. Match the healthcare sector term to the respective description.',
                left: ['Healthcare provider', 'Business associates', 'Health plan', 'Healthcare clearinghouse'],
                right: [
                    'A person or an organization that provides patient or medical services',
                    'A person or organization that performs certain functions involving the use of PHI on behalf of, or provides services to, a covered entity',
                    'A government program that pays for healthcare',
                    'An entity that processes nonstandard health information it receives from another entity into a standard format'
                ],
                correct: {0:0, 1:1, 2:2, 3:3}
            },
            {
                type: 'matching',
                question: '14. Match penetration testing methodology and standard with the respective description.',
                left: ['OSSTMM', 'NIST', 'MITRE ATT&CK', 'OWASP WSTG'],
                right: [
                    'This is a peer-reviewed security testing methodology maintained by the Institute for Security and Open Methodologies (ISECOM).',
                    'This is a document created to provide organizations with guidelines on planning and conducting information security testing.',
                    'This is a resource for learning about the tactics of an adversary, techniques, and procedures (TTPs).',
                    'This is a compilation of high-level phases of web application security testing and digs deeper into the testing methods used.'
                ],
                correct: {0:0, 1:1, 2:2, 3:3}
            },
            {
                type: 'matching',
                question: '30. Match the cloud attack to the description.',
                left: ['Credential Harvesting', 'Account Takeover', 'Privilege Escalation'],
                right: [
                    'Act of gathering and stealing valid usernames, passwords, tokens, PINs, and any other types of credentials through infrastructure breaches',
                    'When a threat actor gains access to a user or application account and uses it to then gain access to more accounts and information',
                    'Act of exploiting a bug or design flaw in a software or firmware application to gain access to resources that normally would have been protected from an application or a user'
                ],
                correct: {0:0, 1:1, 2:2}
            },
            {
                type: 'matching',
                question: '32. Match the mobile device security testing tool to the description.',
                left: ['Drozer', 'Needle', 'ApkX', 'Burp Suite'],
                right: [
                    'This Android testing platform and framework provides access to numerous exploits that can be used to attack Android platforms.',
                    'This open-source framework is used to test the security of iOS applications.',
                    'This tool enables you to decompile Android application package files.',
                    'This can test mobile applications and determine how they communicate with web services and APIs.'
                ],
                correct: {0:0, 1:1, 2:2, 3:3}
            },
            {
                type: 'matching',
                question: '33. Match the mobile device attack to the description.',
                left: ['Spamming', 'Reverse engineering', 'Sandbox analysis'],
                right: [
                    'This presents users with links to redirect them to malicious sites to steal sensitive information or install malware.',
                    'This is the process of analyzing a mobile app to extract information about the source code to understand the underlying architecture of a mobile application and potentially manipulate the mobile device.',
                    'This can enable a threat actor to bypass the access control mechanisms implemented by Android, Apple iOS, and mobile app developers.'
                ],
                correct: {0:0, 1:1, 2:2}
            },
            {
                type: 'matching',
                question: '35. Match the insecure code practice to the description.',
                left: ['Lack of error handling and overly verbose error handling', 'Comments in source code', 'Unprotected APIs', 'Hard-coded credentials'],
                right: [
                    'A type of weakness and security malpractice that can provide information to help an attacker perform additional attacks on the targeted system.',
                    'Developers include information in source code that could provide too much information and might be leveraged by an attacker.',
                    'Many APIs lack adequate controls and are difficult to monitor. The breadth and complexity of APIs also make it difficult to automate effective security testing.',
                    'A catastrophic flaw that an attacker can leverage to completely compromise an application or the underlying system.'
                ],
                correct: {0:0, 1:1, 2:2, 3:3}
            },
            {
                type: 'matching',
                question: '38. Match the PowerSploit module/script to the respective description.',
                left: ['Invoke-Portscan', 'Set-CriticalProcess', 'PowerView', 'Get-VaultCredential', 'PowerUp'],
                right: [
                    'Does a simple TCP port scan using regular sockets, based rather loosely on Nmap',
                    'Causes the machine to blue screen upon exiting PowerShell',
                    'Performs network and Windows domain enumeration and exploitation',
                    'Displays Windows vault credential objects, including plaintext web credentials',
                    'Acts as clearinghouse of common privilege escalation checks, along with some weaponization vectors'
                ],
                correct: {0:0, 1:1, 2:2, 3:3, 4:4}
            }
        ];

        let shuffledQuestions = [];
        let currentQuestionIndex = 0;
        let correctAnswersCount = 0;

        const startScreen = document.getElementById('start-screen');
        const quizContainer = document.getElementById('quiz-container');
        const resultScreen = document.getElementById('result-screen');
        const startBtn = document.getElementById('start-btn');
        const submitBtn = document.getElementById('submit');
        const retryBtn = document.getElementById('retry');
        const nextBtn = document.getElementById('next');
        const restartBtn = document.getElementById('restart-btn');

        startBtn.addEventListener('click', startQuiz);
        submitBtn.addEventListener('click', checkAnswer);
        retryBtn.addEventListener('click', retryQuestion);
        nextBtn.addEventListener('click', nextQuestion);
        restartBtn.addEventListener('click', () => location.reload());

        function startQuiz() {
            startScreen.style.display = 'none';
            quizContainer.style.display = 'block';

            // Перемешиваем вопросы
            shuffledQuestions = [...originalQuestions].sort(() => Math.random() - 0.5);
            currentQuestionIndex = 0;
            correctAnswersCount = 0;

            loadQuestion();
        }

        function loadQuestion() {
            const baseQuestion = shuffledQuestions[currentQuestionIndex];

            // Создаём копию с перемешанными left и right
            const currentQuestion = JSON.parse(JSON.stringify(baseQuestion));

            // Перемешиваем left (то, что нужно соединять)
            const shuffledLeftIndices = currentQuestion.left.map((_, idx) => idx);
            for (let i = shuffledLeftIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledLeftIndices[i], shuffledLeftIndices[j]] = [shuffledLeftIndices[j], shuffledLeftIndices[i]];
            }

            const shuffledLeft = shuffledLeftIndices.map(i => currentQuestion.left[i]);

            // Корректируем correct под новый порядок left
            const newCorrect = {};
            shuffledLeftIndices.forEach((oldIndex, newIndex) => {
                newCorrect[newIndex] = currentQuestion.correct[oldIndex];
            });
            currentQuestion.correct = newCorrect;

            document.getElementById('question-counter').textContent = `Вопрос ${currentQuestionIndex + 1} из 7`;
            document.getElementById('question').textContent = currentQuestion.question;
            document.getElementById('options').innerHTML = '';
            document.getElementById('feedback').innerHTML = '';
            document.getElementById('quiz-container').classList.remove('correct', 'incorrect');
            submitBtn.style.display = 'inline';
            retryBtn.style.display = 'none';
            nextBtn.style.display = 'none';

            const table = document.createElement('table');
            table.classList.add('matching-table');

            shuffledLeft.forEach((leftItem, index) => {
                const row = document.createElement('tr');

                const leftTd = document.createElement('td');
                leftTd.classList.add('matching-left');
                leftTd.textContent = leftItem;
                row.appendChild(leftTd);

                const arrowTd = document.createElement('td');
                arrowTd.textContent = '→';
                arrowTd.style.textAlign = 'center';
                arrowTd.style.fontWeight = 'bold';
                row.appendChild(arrowTd);

                const rightTd = document.createElement('td');
                rightTd.classList.add('matching-right');
                const select = document.createElement('select');
                select.dataset.leftIndex = index; // индекс в перемешанном left

                const defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = '-- выберите --';
                select.appendChild(defaultOpt);

                // Перемешиваем right
                const shuffledRight = [...currentQuestion.right];
                for (let i = shuffledRight.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledRight[i], shuffledRight[j]] = [shuffledRight[j], shuffledRight[i]];
                }

                shuffledRight.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = currentQuestion.right.indexOf(item);
                    opt.textContent = item;
                    select.appendChild(opt);
                });

                rightTd.appendChild(select);
                row.appendChild(rightTd);

                table.appendChild(row);
            });

            document.getElementById('options').appendChild(table);
        }

        function checkAnswer() {
            const baseQuestion = shuffledQuestions[currentQuestionIndex];
            const currentCorrect = baseQuestion.correct; // уже скорректирован под перемешанный left

            const selects = document.querySelectorAll('select');
            const userMatches = {};
            let allSelected = true;

            selects.forEach(select => {
                const leftIndex = parseInt(select.dataset.leftIndex);
                const selectedValue = parseInt(select.value);
                if (select.value === '') allSelected = false;
                userMatches[leftIndex] = selectedValue;
            });

            if (!allSelected) {
                document.getElementById('feedback').innerHTML = '<strong>Выберите ответ для всех строк!</strong>';
                return;
            }

            let isCorrect = Object.keys(currentCorrect).every(key => 
                currentCorrect[key] === userMatches[key]
            );

            submitBtn.style.display = 'none';

            if (isCorrect) {
                correctAnswersCount++;
                document.getElementById('quiz-container').classList.add('correct');
                document.getElementById('feedback').innerHTML = '<strong>Правильно!</strong>';
                nextBtn.style.display = 'inline';
            } else {
                document.getElementById('quiz-container').classList.add('incorrect');
                document.getElementById('feedback').innerHTML = '<strong>Неправильно.</strong><br>Правильные пары:<br>' + getCorrectAnswerText(baseQuestion);
                retryBtn.style.display = 'inline';
            }
        }

        function getCorrectAnswerText(q) {
            return Object.entries(q.correct)
                .map(([leftIdx, rightIdx]) => `${q.left[leftIdx]} → ${q.right[rightIdx]}`)
                .join('<br>');
        }

        function retryQuestion() {
            loadQuestion();
        }

        function nextQuestion() {
            currentQuestionIndex++;
            if (currentQuestionIndex < originalQuestions.length) {
                loadQuestion();
            } else {
                showResult();
            }
        }

        function showResult() {
            quizContainer.style.display = 'none';
            resultScreen.style.display = 'block';

            const percentage = Math.round((correctAnswersCount / originalQuestions.length) * 100);

            document.getElementById('result-score').textContent = `${correctAnswersCount} из 7`;
            document.getElementById('result-text').innerHTML = `
                Процент правильных: <strong>${percentage}%</strong><br><br>
                ${percentage === 100 ? 'Идеально! Ты мастер сопоставлений!' :
                  percentage >= 70 ? 'Отлично! Продолжай в том же духе.' :
                  'Хорошо, ещё немного практики — и будет 100%'}
            `;
        }
    </script>
</body>
</html>
